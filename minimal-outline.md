Outline of the minimal topics I want to talk about in the Uncourse

What is the minimum someone would need to know to contribute to miniKanren research, for example?

# Scheme --- our Linga Franca, and a Hacker's Dream
## Scheme as a simple language for expressing computation.
## Scheme as a Hacker's Dream
## Scheme's design and tradeoffs, what it emphasizes and de-emphasizes, etc.

# Functional programming
## The idea of functional programming
## The promise of functional programming
## The tradeoffs inherent in functional programming (at least, as practiced today)

# Program transformations
## CPS as the ultimate gateway drug of program transformations
## Representation independence (with respect to X)
## Defunctionalization

# miniKanren
## Relational and non-relational features
## Invariants
## Reification

# Relational programming
## The idea of relational programming
## The promise of relational programming
## The tradeoffs inherent in relational programming (at least, as practiced today)

# Programming languages
## Syntax
## Types
## Parsers
## Interpreters
## Type checkers
## Type inferencers

# Automated reasoning
## Proof assistants
## Automated theorem proving
## SAT/SMT solvers

# Program synthesis

# Independence, self-reliance, and self-confidence in research
* Research is hard.  Generally speaking, people will either ignore your work or try to poke holes in it.  The hardest part may be getting to the point where people bother criticizing your work, since at least by that point you have their attention.
* Jack Sparrow image macro: "miniKanren is without a doubt the worst logic programming language I've ever heard of."  "But you *have heard of it*"
* "Your critics are your friends" -- Matthias Felleisen
## Ability to get unstuck as a definition of intelligent beavior -- Minsky

# Reading, understanding, implementing
## Reading a specification -- for example, the R6RS report
### Mental models, prediction, and "what if?" thinking
### Adversarial thinking -- looking for hiddent assumptions (especially in proofs, including impossibility proofs, such as in the Halting Problem/undecidability)
### Try it!  Make a prediction, write code, check the prediction against the actual behavior.  Always make the prediction first.  Even better, write down the prediction (perhaps in the form of an executable test)

# Communication
* Precision of thought and expression
* Clarity and simplicity
## Common pitfalls
* Communicating to impress, rather than to clearly express ideas
** Technical jargon
** Unnecessary complexity
## Writing
## Speaking
## Documentation
### Invariants

# Finding, nurturing, assessing ideas
## Fashion in research

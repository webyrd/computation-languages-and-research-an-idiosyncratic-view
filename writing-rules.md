Writing Rules for 'Computation, Languages, and Research: An Idiosyncratic View'

* I plan to work on all of these books simultaneously, of course, for good or for bad!  At least this should help me with the dependencies, since I can "work backwards" if I want, add sections to the first book and the last book simultaneously, etc.

* keep working on the Uncourse -- long-term project; however, try to get things into a useful, usable state in the relatively near term (for some values of "near term")

* work in the open

* CC-BY 4.0 International license

* try to be efficient, in that if someone asks me to explain something, see if I can write up what I have in mind as part of this Uncourse

* Stick with pandoc and Markdown.  I'm not super happy with the PDF output from pandoc so far, but Markdown is easy to work with, accessible, and I don't spend all my time messing around with LaTeX typesetting.  Maybe I can at least adjust the margins for PDF output from pandoc---the margins are so huge!

* Idiosyncratic, personal point of view.  Not an encyclopedia of everything that could be taught or explored in computing (as if I could even write such a thing).

* Trajectory, coherence, point-of-view, and intellectual stance are important---much more important than trying to replace a CS undergrad/grad program.

* Assumption is that the learner will learn from many resources other than this Uncourse.  This Uncourse can provide an arc/trajectory/way of looking at computation, programming, programming languages, research, etc., that is unique, and that can't be discovered by taking a bunch of individual classes/reading individual books on specific technical topics by a bunch of people.

* Show what is fascinating, weird, bizarre, inspiring, IMHO.

* Scheme, miniKanren/relational programming, my personal approach to research and thinking and communication, should all shine through.

* The ultra cool parts of Scheme and miniKanren/relational programming need to shine.  One disadvantage with the way Scheme is often taught, I think, is that it often looks to students like Scheme is this wimpy language that professors who don't know the Latest Coolest Tool/Language/Framework/Thingy from a FAANG use because they don't know any better, or whatever.  The reality is that Scheme is a hacker's dream.  That should shine through, and not only at the end.

* Include the cool and powerful techniques that you'd have to go to grad school or study under a hacker at a school strong in Scheme (or miniKanren, or whatever).  Program transformations, meta-programming, relational interpreters, program synthesis, angelic execution, macros, delimited continuations, TMSes, advanced symbolic computation, automated theorem proving, language design, etc.

* Include my perspective on how to communicate in various ways (writing a paper, giving a talk, etc.), what seemed to work for me in grad school, etc.  Of course, these things may not work for everyone.  Might at least give people a starting point, or things to try, or to react to ("I *hate* that approach!" is a fine reaction!).

* Point to the great resources, including books, languages, courses, videos, lectures, papers, tools, etc.

* My personal communication style and personality and sense of fun and humor should also shine through.

* Light a fire, don't fill a bucket.

* Fun to write, fun to read, fun to hack, fun to explain, fun to think about.

* Nerd Chills, Artosis style

* Use this Uncourse as a chance for *me* to explore and learn.  However, don't use his learning as an excuse to not work on the Uncourse.  It's okay to say that I don't know something, or don't understand it all that well.

* Cool Things:
program transformations, continuations (incl. delimited), streams, interpreters, relational programming, program synthesis, macros, staged evaluation, automated theorem proving, SAT/SMT, Monte Carlo simulation + RL, probabilistic programming, reversible computing, quines, self-reps, lambda calculus, combinatory logic, computation in living cells, undecidability, halting problem, Chomsky Hierarchy, concatenative languages, quine relays, FPGA, NAND, microcontrollers, fractals and complexity/chaos, sequent calculus, ill-typed type system, abstract interpretation, compilers, abstract machines, virtual machines, cellular automata, unusual models of computation (billiad ball, for example)

* Triage the cool things, and make sure to include the ones I most want to talk about.  Work backwards wrt dependencies.  Leave out the boring stuff!  :P  Of course, there is no boring stuff if you go deep enough.  However, I should find alternative ways to talk about things I don't find very inspiring right now, like how I used microcontrollers to talk about side effects and mutable state back in the day.

* Put compelling, deep, fascinating ideas as early as I can get away with.

* Idea: I wonder how much of this I could explore functionally, and relationally?
